
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Blog</title>
    <meta name="description" content="Johnson Lab blog">
    <meta name="author" content="Matthew G. Johnson">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

    <!-- Bootstrap styles -->
    <link href="/assets/themes/lab/bootstrap/css/bootstrap.min.css" rel="stylesheet"/>
    <!-- Optional theme -->
    <link href="/assets/themes/lab/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet"/>
    <!-- Sticky Footer -->
    <link href="/assets/themes/lab/bootstrap/css/bs-sticky-footer.css" rel="stylesheet"/>
    
    <!-- Custom styles -->
    <link href="/assets/themes/lab/css/style.css?body=1" rel="stylesheet" type="text/css" media="all"/>

    <!-- icon -->
    <link rel="shortcut icon" href="/assets/themes/lab/images/logo/favicon.jpg"/>

    <!-- Custom fonts and icons via Font Awesome, http://fortawesome.github.io/Font-Awesome/ -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"/>

    <!-- Fonts via Google -->
    <link href='http://fonts.googleapis.com/css?family=Lato:300italic,700italic,300,700' rel='stylesheet' type='text/css'/>

    <!-- Math via MathJax -->
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->

    <!-- atom & rss feed
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">
    -->

  </head>

  <body>

  <!-- Static top navbar -->

  <nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class='container'>
      <!-- Brand and toggle get grouped for better mobile display -->
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        
        <a href="/">
        
        <img class="pull-left logo" src="/assets/themes/lab/images/logo/logo.jpg" type="image/svg+xml">
        </a>
        
      </div>

      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="jb-navbar-collapse">
        <ul class="nav navbar-nav navbar-left hidden-sm">
          <!-- Don't put site title on home page -- there's already a big title there. -->
          
          
          
          <a class="navbar-brand" href="/">Mossmatters- Plant Phylogenetics</a>
          
        </ul>
        <ul class="nav navbar-nav navbar-right pull-right">
          
          
          


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
  
    
  
    
      
    
  
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/projects/">Research</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/team/">Team</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/herbarium/">Herbarium</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/papers/">Papers</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li class="active"><a href="/blog/" class="active">Blog</a></li>
      	
      
    
  
    
      
    
  



          <li class="dropdown nav navbar-nav">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
              More <span class="caret"></span>
            </a>

            <ul class="dropdown-menu nav navbar-nav" role="menu">
              
              
              


  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
  
    
  
    
      
    
  
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/protocols/">Protocols</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/news/">News</a></li>
      	
      
    
  



            </ul>
            </li>
        </ul>
      </div><!-- /.navbar-collapse -->
    </nav>
   </div>

   <!-- Content -->
   <div class="container">
      


<div class="pager">
  
	  
  
	  	
    
</div>



	

	<div class="bigspacer"></div>
	<div class="row">
		<div class="col-md-3">
			<div class="head">
				<a href="/blog/welcome" class="off">Welcome to Mossmatters At Texas Tech</a>
			</div>
			<div class="smallnote">
				12 Sep 2017
				
				by <a class="off" href="/team/matt-johnson">mossmatters</a>
								
			</div>	
		</div>
		<div class="col-md-8">		
			<div style="height:5px;"></div>			
			
			<div class="post">
				
<p>New Location, new website! I am excited to join the faculty at Texas Tech University in 2017 as an Assistant Professor and Director of the E.L. Reed Herbarium. To go along with this move, I thought it was time to update the website! The previous version of mossmatters.com was created through WordPress, which I found very unintuitive and occasionally frustrating. For example, they don’t even allow GIFs! How else will the world learn about lab bocce outings?</p>

<p><img src="/assets/images/blog/bocce.gif" alt="" /></p>

<p>The new site is generated by Jekyll, which is the same engine that generates github.io sites. The good news is that I can write nearly all of my content using Markdown. The whole site is generated on my laptop and then uploaded as static webpages.</p>

<p>Over the next few weeks I will be updating the various Pages to reflect ongoing projects and new publications. I will still maintain a blog for writing about new discoveries and adventures in plant phylogenomics. I plan on re-populating the blog with old posts from the previous website, hopefully with some new bells-and-whistles allowed by the new platform!</p>

			</div>
		</div>			
		<div class="col-md-1"></div>
	</div>		



	

	<div class="bigspacer"></div>
	<div class="row">
		<div class="col-md-3">
			<div class="head">
				<a href="/blog/SequenceClusters" class="off">Designing HybSeq Probes from a large sequence alignment</a>
			</div>
			<div class="smallnote">
				31 Oct 2016
				
				by <a class="off" href="/team/matt-johnson">mossmatters</a>
								
			</div>	
		</div>
		<div class="col-md-8">		
			<div style="height:5px;"></div>			
			
			<div class="post">
				<h1 id="designing-hybseq-probes-from-a-large-sequence-alignment">Designing HybSeq Probes from a large sequence alignment</h1>

<p>One of the most important considerations when designing probes for targeted sequencing is how related the the source sequences are to the potential samples that will be enriched. In phylogenetic studies of non-model organisms, there may not be prior sequences available in the target taxa, but minimizing sequence divergence is still important.</p>

<p>One solution is to use any existing sequence data to design probes from multiple ortholgous sources per gene. This effectively increases probe tiling and should also broaden the use of the probe set to more divergent taxa. Given a sequence alignment, we can choose sequences that are representative of specific clades, but this may be biased.</p>

<p>Instead, we can let the data tell us what the most representative sequences should be. In this notebook we will generate pairwise distance matrices from DNA sequence alignments. The distances will be clustered using one or more multivariate statistics techniques (such as k-means clustering or discrimant analysis) to explore the optimal number of clusters for the alignment, and we will select representative sequences from each cluster.</p>

<p>We will use Python implementations of distance matrices and visualizations taken from the <a href="http://readiab.org/book/latest/2/3">Introduction to Applied Bioinformatics</a>.</p>

<pre><code class="language-pyhthon">%matplotlib inline
from skbio import TabularMSA, DNA, DistanceMatrix
from skbio.sequence.distance import hamming, kmer_distance
import pandas as pd
import matplotlib.pyplot as plt

gene = "7653"
fasta_filename = "/Users/mjohnson/Desktop/Projects/AngiospermHybSeq/genes/{}/FNA2AA-upp-masked.fasta".format(gene)
angiosperm_id_fn = "/Users/mjohnson/Desktop/Projects/AngiospermHybSeq/1kp_angio_codes.txt"
angio_1kp_ids = set([x.rstrip() for x in open(angiosperm_id_fn)])

</code></pre>

<h2 id="reading-the-data">Reading the data</h2>

<p>The MSA has a multiple sequence alignemnt of one gene from 1KP. We keep only the sequences from Angiosperms, including genome sequence.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">msa</span> <span class="o">=</span> <span class="n">TabularMSA</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">fasta_filename</span><span class="p">,</span> <span class="n">constructor</span><span class="o">=</span><span class="n">DNA</span><span class="p">)</span>
<span class="n">seqs_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">msa</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">seq</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">"id"</span><span class="p">]</span> <span class="ow">in</span> <span class="n">angio_1kp_ids</span><span class="p">:</span>
        <span class="n">seqs_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        
<span class="n">angio_msa</span> <span class="o">=</span> <span class="n">TabularMSA</span><span class="p">(</span><span class="n">seqs_to_keep</span><span class="p">)</span>        
<span class="n">angio_msa</span><span class="o">.</span><span class="n">reassign_index</span><span class="p">(</span><span class="n">minter</span><span class="o">=</span><span class="s">"id"</span><span class="p">)</span>
<span class="n">angio_msa</span><span class="o">.</span><span class="n">shape</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Shape(sequence=603, position=4956)
</code></pre>
</div>

<p>Now that the alignment contains only angiosperms, remove the positions that are more than 95% gaps:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">angio_msa_dict</span> <span class="o">=</span> <span class="n">angio_msa</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="n">angio_msa_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">angio_msa_dict</span><span class="p">)</span>

<span class="c">#This might throw an error if there are ever any positions without gaps. Seems unlikely for this dataset...</span>

<span class="k">def</span> <span class="nf">gap_dectector</span><span class="p">(</span><span class="n">sequence_column</span><span class="p">):</span>
    <span class="s">'''Returns the number of gap characters in a column of a sequence matrix'''</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sequence_column</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()[</span><span class="n">b</span><span class="s">"-"</span><span class="p">]</span>
    <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="n">gapped_columns</span> <span class="o">=</span> <span class="n">angio_msa_df</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="n">gap_dectector</span> <span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c">#This could be modified to remove columns that have 90% gaps, etc.</span>
<span class="n">angio_msa_df_nogaps</span> <span class="o">=</span> <span class="n">angio_msa_df</span><span class="p">[</span><span class="n">gapped_columns</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">angio_msa_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">]</span>

<span class="c">#In skbio, DNA sequences are stored as bytecode, (b'A') so need to convert back to strings</span>

<span class="n">nogap_seqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DNA</span><span class="p">(</span><span class="n">angio_msa_df_nogaps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="nb">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">"utf-8"</span><span class="p">)</span><span class="o">.</span><span class="nb">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(),</span> <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s">"id"</span><span class="p">:</span><span class="n">i</span><span class="p">})</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">angio_msa_df_nogaps</span><span class="p">]</span>
<span class="n">angio_msa_nogap</span> <span class="o">=</span> <span class="n">TabularMSA</span><span class="p">(</span><span class="n">nogap_seqs</span><span class="p">)</span>
<span class="c">#angio_msa_nogap.write("/Users/mjohnson/Desktop/Projects/AngiospermHybSeq/{}.onlyangios.fasta".format(gene))</span>

<span class="n">angio_msa_nogap</span><span class="o">.</span><span class="n">shape</span>

</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Shape(sequence=603, position=1824)
</code></pre>
</div>

<p>We also want to remove the sequences that have &gt; 50% gaps</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">seqs_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">angio_msa_nogap</span><span class="p">:</span>
    <span class="n">num_gaps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="o">.</span><span class="n">gaps</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">num_gaps</span> <span class="o">&lt;</span> <span class="n">angio_msa_nogap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="n">seqs_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        
<span class="n">angio_msa_nogap_noshort</span> <span class="o">=</span> <span class="n">TabularMSA</span><span class="p">(</span><span class="n">seqs_to_keep</span><span class="p">)</span>
<span class="n">angio_msa_nogap_noshort</span><span class="o">.</span><span class="n">reassign_index</span><span class="p">(</span><span class="n">minter</span><span class="o">=</span><span class="s">"id"</span><span class="p">)</span>

<span class="n">angio_msa_nogap_noshort</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">"/Users/mjohnson/Desktop/Projects/AngiospermHybSeq/onekp_only_angios_degapped/{}.onlyangios.noshort.fasta"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gene</span><span class="p">))</span>
<span class="n">angio_msa_nogap_noshort</span><span class="o">.</span><span class="n">shape</span>
        
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Shape(sequence=307, position=1824)
</code></pre>
</div>

<h2 id="distance-matrix">Distance Matrix</h2>

<p>We calculate the “Hamming distance” as described here: http://readiab.org/book/latest/2/4#6.3</p>

<p>The Hamming distance between two equal-length sequences is the proportion of differing characters.</p>

<p>We make a small adjustment to only calculate the Hamming distance between sites with no gaps (equivalent to the p-distance calculated by PAUP*)</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">p_distance</span><span class="p">(</span><span class="n">seq1</span><span class="p">,</span><span class="n">seq2</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">skbio.sequence</span> <span class="kn">import</span> <span class="n">Sequence</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">isnan</span>
    <span class="n">myseq1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq1</span><span class="p">)</span>
    <span class="n">myseq2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">seq2</span><span class="p">)</span>
    
    <span class="n">degapped1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">degapped2</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">myseq1</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">myseq1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"-"</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">myseq2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">"-"</span><span class="p">:</span>
                <span class="n">degapped1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">myseq1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">degapped2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">myseq2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">degapped1</span> <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">degapped1</span><span class="p">)</span>
    <span class="n">degapped2</span> <span class="o">=</span> <span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">degapped2</span><span class="p">)</span>
    
    <span class="c">#print(degapped1)</span>
    <span class="c">#print(degapped2)</span>
    
    <span class="n">hamming_dist</span> <span class="o">=</span> <span class="n">hamming</span><span class="p">(</span><span class="n">Sequence</span><span class="p">(</span><span class="n">degapped1</span><span class="p">),</span><span class="n">Sequence</span><span class="p">(</span><span class="n">degapped2</span><span class="p">))</span>
    <span class="c">#print(hamming_dist)</span>
    <span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="n">hamming_dist</span><span class="p">):</span>
        <span class="c">#print(seq1.metadata["id"], seq2.metadata["id"])</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hamming_dist</span>


<span class="n">p_dm</span> <span class="o">=</span> <span class="n">DistanceMatrix</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">angio_msa_nogap_noshort</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">hamming</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s">'id'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Distance between Amborella and Rice:"</span><span class="p">)</span>
<span class="n">p_dm</span><span class="p">[</span><span class="s">"Ambtr_v1.0.27"</span><span class="p">,</span><span class="s">"Orysa_v7.0"</span><span class="p">]</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Distance between Amborella and Rice:





0.46052631578947367
</code></pre>
</div>

<p>The square pairwise distance matrix is shown below.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">_</span> <span class="o">=</span> <span class="n">p_dm</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="s">'Blues'</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s">'Pairwise Dissimilarity between sequences, gene {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gene</span><span class="p">))</span>
<span class="n">p_dm_df</span> <span class="o">=</span> <span class="n">p_dm</span><span class="o">.</span><span class="n">to_data_frame</span><span class="p">()</span>
<span class="n">p_dm_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s">"/Users/mjohnson/Desktop/Projects/AngiospermHybSeq/onekp_only_angios_pdistance/{}_angio_p_dm.csv"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gene</span><span class="p">))</span>
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_11_0.png" alt="png" /></p>

<h2 id="finding-representative-sequences--manual-selection">Finding Representative Sequences – Manual Selection</h2>

<p>Now that we have a distance matrix, the next step is to decide which “representative” sequences are best for designing target capture probes. From the figure above we can see that some sequences diverged up to 80%, which is well beyond the tolerated range of 15-25%.</p>

<p>One solution is to manually choose sequences. For instance, we could choose only genomic sequences that we “know” to be relatively diverged from one another, and hope that they represent the spectrum of divergences for this gene. Let’s try this by choosing: <em>Arabidopsis</em>, <em>Amborella</em>, <em>Oryza</em>, <em>Vitis</em>, <em>Mimulus</em>, and <em>Populus</em>.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">manual_centroids</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Arath_TAIR10"</span><span class="p">,</span><span class="s">"Ambtr_v1.0.27"</span><span class="p">,</span><span class="s">"Orysa_v7.0"</span><span class="p">,</span><span class="s">"Vitvi_Genoscope.12X"</span><span class="p">,</span><span class="s">"Mimgu_v2.0"</span><span class="p">,</span><span class="s">"Poptr_v3.0"</span><span class="p">]</span>
<span class="n">manual_centroid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">manual_centroids</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">manual_centroid_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Minimum Distance to Centroid, Manual Centroids </span><span class="se">\n</span><span class="s"> Gene {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gene</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Number of Distances &gt; 30</span><span class="si">%</span><span class="s">: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">manual_centroid_dist</span><span class="p">[</span><span class="n">manual_centroid_dist</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">])))</span>

</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Number of Distances &gt; 30%: 269
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_13_1.png" alt="png" /></p>

<p>There are too many sequences that are diverged more than 25% from each of our manually chosen sequences. The same is true even if we select all of the genome sequences:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">all_genomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p_dm_df</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">all_genomes_centroid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">all_genomes</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">all_genomes_centroid_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Centroids: "</span><span class="p">,</span><span class="n">all_genomes</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Minimum Distance to Centroid, All Genome Centroids </span><span class="se">\n</span><span class="s"> Gene {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gene</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Number of Distances &gt; 30</span><span class="si">%</span><span class="s">: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_genomes_centroid_dist</span><span class="p">[</span><span class="n">all_genomes_centroid_dist</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">])))</span>


</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Centroids:  ['Ambtr_v1.0.27', 'Aquco_v1.1', 'Arath_TAIR10', 'Eucgr_v1.1', 'Manes_v4.1', 'Mimgu_v2.0', 'Orysa_v7.0', 'Phavu_v1.0', 'Poptr_v3.0', 'Prupe_v1.0', 'Solly_iTAGv2.3', 'Sorbi_v2.1', 'Theca_v1.1', 'Vitvi_Genoscope.12X']

Number of Distances &gt; 30%: 247
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_15_1.png" alt="png" /></p>

<h2 id="k-means-clustering">K-means clustering</h2>

<p>Instead, we could let the distances themselves tell us which sequences are best, by clustering the sequences by their pairwise dissimilarity. By pre-selecting a number of clusters, we can let the data tell us which sequences cluster together, and then choose a representative from each cluster.</p>

<p>Based on example from: http://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_digits.html#example-cluster-plot-kmeans-digits-py</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">metrics</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_digits</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="n">n_digits</span> <span class="o">=</span> <span class="mi">6</span> <span class="c">#number of clusters</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">p_dm_df</span><span class="p">)</span>

<span class="n">reduced_data</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">p_dm_df</span><span class="p">)</span>

<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="s">'k-means++'</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_digits</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span>

<span class="c"># Step size of the mesh. Decrease to increase the quality of the VQ.</span>
<span class="n">h</span> <span class="o">=</span> <span class="o">.</span><span class="mo">02</span>     <span class="c"># point in the mesh [x_min, m_max]x[y_min, y_max].</span>

<span class="c"># Plot the decision boundary. For that, we will assign a color to each</span>
<span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nb">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="nb">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nb">min</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="nb">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>

<span class="c"># Obtain labels for each point in mesh. Use last trained model.</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>

<span class="c"># Put the result into a color plot</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">,</span>
           <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="nb">min</span><span class="p">(),</span> <span class="n">xx</span><span class="o">.</span><span class="nb">max</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="nb">min</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="nb">max</span><span class="p">()),</span>
           <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Paired</span><span class="p">,</span>
           <span class="n">aspect</span><span class="o">=</span><span class="s">'auto'</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s">'lower'</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'k.'</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c"># Plot the centroids as a white X</span>
<span class="n">centroids</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">centroids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centroids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">marker</span><span class="o">=</span><span class="s">'x'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">169</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s">'w'</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">'K-means clustering on the DNA sequence dataset </span><span class="se">\n</span><span class="s">(PCA-reduced distance matrix)</span><span class="se">\n</span><span class="s">'</span>
          <span class="s">'Centroids are marked with white cross'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_17_0.png" alt="png" /></p>

<p>The figure plots the PCA transformation of the distance matrix– the axes correspond to PCA1 and PCA2, and each point represents a sequence in the alignment.</p>

<p>The polygons are drawn to estimate the cluster boundaries in two dimensions.</p>

<p>The white X represents the “centroid” of each cluster.</p>

<h2 id="finding-representative-sequences--cluster-centroids">Finding representative sequences – cluster centroids</h2>

<p>Now that we have predicted clusters, are these clusters sufficient to have all sequences within the cluster be no more than 30% divergent?</p>

<p>For each cluster, we figure out which of the real sequences in each cluster is closest to the centroid (Euclidean distance). Then we figure out the maximum pairwise distance any sequence and the centroid sequences.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c">#Group the distance matrix by kmeans clusters</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>

<span class="n">grouped</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
<span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">group</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
    <span class="c">#print("Group number: {}".format(name))</span>
    
    <span class="c">#Find the sample that is closest to the centroid. This is a pd Dataframe row index.</span>
    <span class="n">closest_to_centroid</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">distance</span><span class="o">.</span><span class="n">euclidean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">name</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c">#print("Number of sequences in group: {}".format(len(group)))</span>
    
    <span class="c">#Reduce the distance matrix to be square within the group</span>
<span class="c">#    reduced_group = group[group.index]</span>
<span class="c">#    print("Max distance within group: {}".format(max(reduced_group.apply(max))))</span>
    <span class="n">closest_id</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">closest_to_centroid</span><span class="p">]</span>
    <span class="c">#print("ID closest to centroid (Euclidean): {}".format(closest_id))</span>
    <span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_id</span><span class="p">)</span>
    
<span class="c">#    print("Furthest within-group P distance distances to centroids ID:")</span>
<span class="c">#    print(reduced_group[closest_id].sort_values(ascending=False)[0:2])</span>
<span class="c">#    print()</span>
<span class="c">#centroids.append("Arath_TAIR10")</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Centroids: "</span><span class="p">,</span> <span class="n">centroids</span><span class="p">)</span>
<span class="n">centroid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">centroids</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">centroid_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Minimum Distance to Centroid, {} Clusters</span><span class="se">\n</span><span class="s"> Gene {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_digits</span><span class="p">,</span><span class="n">gene</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Number of Distances &gt; 30</span><span class="si">%</span><span class="s">: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centroid_dist</span><span class="p">[</span><span class="n">centroid_dist</span> <span class="o">&gt;</span> <span class="mf">0.30</span><span class="p">])))</span>

</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Centroids:  ['LQJY', 'AYIY', 'PUDI', 'QZXQ', 'KJAA', 'EQDA']

Number of Distances &gt; 30%: 240
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_20_1.png" alt="png" /></p>

<p>Before, using sequences from all of the genomes left almost twice as many sequences with &gt; 30% divergence. Ideally, we could pick the number of clusters that minimizes the number of sequences with &gt; 30% divergence.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">divergent_seqs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">p_dm_df</span><span class="p">)</span>
<span class="n">reduced_data</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">p_dm_df</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">n_digits</span> <span class="o">=</span> <span class="n">i</span> <span class="c">#number of clusters</span>

    <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="s">'k-means++'</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_digits</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span>
    <span class="n">grouped</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
    <span class="n">centroids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">group</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>    
        <span class="c">#Find the sample that is closest to the centroid. This is a pd Dataframe row index.</span>
        <span class="n">closest_to_centroid</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">distance</span><span class="o">.</span><span class="n">euclidean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">name</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">closest_id</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">closest_to_centroid</span><span class="p">]</span>
        <span class="n">centroids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_id</span><span class="p">)</span>
    <span class="c">#print("Centroids: ", centroids)</span>
    <span class="n">centroid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">centroids</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">num_over_25</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">centroid_dist</span><span class="p">[</span><span class="n">centroid_dist</span> <span class="o">&gt;</span> <span class="mf">0.30</span><span class="p">])</span>
    <span class="n">divergent_seqs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">num_over_25</span><span class="p">))</span>
    
    <span class="c">#centroid_dist.hist(bins=40)</span>
    <span class="c">#plt.title("Minimum Distance to Centroid, {} Clusters\n Gene {}".format(n_digits,gene))</span>
    <span class="c">#print("\n\n Distances &gt; 25%:")</span>
    <span class="c">#print("\nNumber of Distances &gt; 25%: {}".format(len(centroid_dist[centroid_dist &gt; 0.25])))</span>

<span class="n">divergent_seqs_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">divergent_seqs</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">"NumClusters"</span><span class="p">,</span><span class="s">"NumDivergent"</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">divergent_seqs_df</span><span class="o">.</span><span class="n">NumClusters</span><span class="p">,</span><span class="n">divergent_seqs_df</span><span class="o">.</span><span class="n">NumDivergent</span><span class="p">,</span><span class="s">'-o'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">"Number of clusters"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Number of sequences with &gt; 30</span><span class="si">% </span><span class="s">divergence from any centroid"</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;matplotlib.text.Text at 0x10df71278&gt;
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_22_1.png" alt="png" /></p>

<p>The number of sequences with &gt; 30% divergence may fluctuate as the number of clusters is increased because the clusters (and centroids) may be chosen differently if the kmeans fit is repeated. In this case, choosing 13 or more clusters will have the best effect.</p>

<h2 id="spectral-clustering">Spectral Clustering</h2>

<p>Another option for assigning sequences to clusters is spectral clustering.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">spectral_clustering</span>

<span class="n">similarity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p_dm_df</span> <span class="o">/</span> <span class="n">p_dm_df</span><span class="o">.</span><span class="n">std</span><span class="p">())</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>

<span class="n">labels</span> <span class="o">=</span> <span class="n">spectral_clustering</span><span class="p">(</span><span class="n">similarity</span><span class="p">,</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">assign_labels</span> <span class="o">=</span> <span class="s">'discretize'</span><span class="p">)</span>
<span class="n">colormap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s">"r"</span><span class="p">,</span><span class="s">"g"</span><span class="p">,</span><span class="s">"b"</span><span class="p">,</span><span class="s">"w"</span><span class="p">,</span><span class="s">"purple"</span><span class="p">,</span><span class="s">"orange"</span><span class="p">,</span><span class="s">"brown"</span><span class="p">,</span><span class="s">"lightblue"</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reduced_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="n">colormap</span><span class="p">[</span><span class="n">labels</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>/usr/local/lib/python3.5/site-packages/sklearn/utils/validation.py:629: UserWarning: Array is not symmetric, and will be converted to symmetric by average with its transpose.
  warnings.warn("Array is not symmetric, and will be converted "
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_25_1.png" alt="png" /></p>

<p>The assignment of sequences to clusters is less important than reliably definining a “representative,” so we may need to explore alternative ways of “reducing” the distance data besides PCA.</p>

<h2 id="k-medoids">K Medoids</h2>

<p>Another way to choose representative sequences is to use the k-medoid approach: https://en.wikipedia.org/wiki/K-medoids</p>

<p>The principle is similar to k-means clustering, in that clusters are made by minimizing within-group distances. However, instead of centroids (which represent the “mean” of a cluster), the clusters are keyed around a specific point within the cluster (analagous to a median). As a result, there will be no need to calculate which point is closest to the centroid, instead one specific sequence will be chosen as the medoid of each cluster.</p>

<p>Python medoid code is taken from here: https://github.com/letiantian/kmedoids
The implementation of this method of calculating k-medoids in python is discussed here: https://www.researchgate.net/publication/272351873_NumPy_SciPy_Recipes_for_Data_Science_k-Medoids_Clustering</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">kMedoids</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="c"># determine dimensions of distance matrix D</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span>

    <span class="c"># randomly initialize an array of k medoid indices</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>

    <span class="c"># create a copy of the array of medoid indices</span>
    <span class="n">Mnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

    <span class="c"># initialize a dictionary to represent clusters</span>
    <span class="n">C</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tmax</span><span class="p">):</span>
        <span class="c"># determine clusters, i. e. arrays of data indices</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span><span class="n">M</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">C</span><span class="p">[</span><span class="n">kappa</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span><span class="o">==</span><span class="n">kappa</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c"># update cluster medoids</span>
        <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">kappa</span><span class="p">],</span><span class="n">C</span><span class="p">[</span><span class="n">kappa</span><span class="p">])],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
            <span class="n">Mnew</span><span class="p">[</span><span class="n">kappa</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">kappa</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Mnew</span><span class="p">)</span>
        <span class="c"># check for convergence</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Mnew</span><span class="p">):</span>
            <span class="k">break</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Mnew</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># final update of cluster memberships</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">D</span><span class="p">[:,</span><span class="n">M</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">kappa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">C</span><span class="p">[</span><span class="n">kappa</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span><span class="o">==</span><span class="n">kappa</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># return results</span>
    <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">C</span>
</code></pre>
</div>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">medoids</span><span class="p">,</span> <span class="n">membership</span> <span class="o">=</span>  <span class="n">kMedoids</span><span class="p">(</span><span class="n">p_dm</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="n">medoid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">p_dm_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">medoids</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Number of Distances &gt; 30</span><span class="si">%</span><span class="s">: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">medoid_dist</span><span class="p">[</span><span class="n">medoid_dist</span> <span class="o">&gt;</span> <span class="mf">0.30</span><span class="p">])))</span>
<span class="n">medoid_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Number of Distances &gt; 30%: 148





&lt;matplotlib.axes._subplots.AxesSubplot at 0x1101845f8&gt;
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_29_2.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">divergent_seqs_medoids</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">medoids</span><span class="p">,</span><span class="n">membership</span> <span class="o">=</span> <span class="n">kMedoids</span><span class="p">(</span><span class="n">p_dm</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="n">medoid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">p_dm_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">medoids</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num_over_25</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">medoid_dist</span><span class="p">[</span><span class="n">medoid_dist</span> <span class="o">&gt;</span> <span class="mf">0.30</span><span class="p">])</span>
        <span class="n">divergent_seqs_medoids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">num_over_25</span><span class="p">))</span>
    <span class="k">except</span> <span class="nb">ValueError</span><span class="p">:</span>
        <span class="n">divergent_seqs_medoids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>

<span class="n">divergent_seqs_medoids_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">divergent_seqs_medoids</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">"NumClusters"</span><span class="p">,</span><span class="s">"NumDivergent"</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">divergent_seqs_df</span><span class="o">.</span><span class="n">NumClusters</span><span class="p">,</span><span class="n">divergent_seqs_medoids_df</span><span class="o">.</span><span class="n">NumDivergent</span><span class="p">,</span><span class="s">'-o'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">"Number of clusters"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Number of sequences with &gt; 30</span><span class="si">% </span><span class="s">divergence from any medoid"</span><span class="p">)</span>    
    
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>/usr/local/lib/python3.5/site-packages/numpy/core/_methods.py:59: RuntimeWarning: Mean of empty slice.
  warnings.warn("Mean of empty slice.", RuntimeWarning)





&lt;matplotlib.text.Text at 0x10e50e438&gt;
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_30_2.png" alt="png" /></p>

<p>Some iterations return an error that I’m not quite sure how to fix…</p>

<p>It appears that clusters can vary greatly based on individual runs of the k-medoids (or k-means) clustering. This problem is best illustrated with this YouTube video: https://www.youtube.com/watch?v=9nKfViAfajY</p>

<p>It really doesn’t matter for our purposes which cluster each sequence belongs to. Our task is a minimizaiton exercise, so we should repeat each value of K a number of times.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">divergent_seqs_medoids</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">50</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">medoids</span><span class="p">,</span><span class="n">membership</span> <span class="o">=</span> <span class="n">kMedoids</span><span class="p">(</span><span class="n">p_dm</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
            <span class="n">medoid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">p_dm_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">medoids</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">num_over_25</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">medoid_dist</span><span class="p">[</span><span class="n">medoid_dist</span> <span class="o">&gt;</span> <span class="mf">0.30</span><span class="p">])</span>
            <span class="n">divergent_seqs_medoids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">num_over_25</span><span class="p">))</span>
        <span class="k">except</span> <span class="nb">ValueError</span><span class="p">:</span>
            <span class="n">divergent_seqs_medoids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>

<span class="n">divergent_seqs_medoids_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">divergent_seqs_medoids</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s">"NumClusters"</span><span class="p">,</span><span class="s">"NumDivergent"</span><span class="p">])</span>
<span class="n">divergent_seqs_medoids_df</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s">"NumClusters"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">"Number of clusters"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">"Number of sequences with &gt; 30</span><span class="si">% </span><span class="s">divergence from any medoid"</span><span class="p">)</span>    
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>/usr/local/lib/python3.5/site-packages/numpy/core/_methods.py:59: RuntimeWarning: Mean of empty slice.
  warnings.warn("Mean of empty slice.", RuntimeWarning)





&lt;matplotlib.text.Text at 0x10f7ebf60&gt;
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_32_2.png" alt="png" /></p>

<p>This suggests that for this gene there <em>does</em> exist a set of just ten taxa that could represent 98% of all seqeunces!</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">k</span><span class="o">=</span><span class="mi">50</span>
<span class="n">best_run</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_dm_df</span><span class="p">)</span>
<span class="n">runs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">medoids</span><span class="p">,</span><span class="n">membership</span> <span class="o">=</span> <span class="n">kMedoids</span><span class="p">(</span><span class="n">p_dm</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="n">medoid_dist</span> <span class="o">=</span> <span class="n">p_dm_df</span><span class="p">[</span><span class="n">p_dm_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">medoids</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num_over_25</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">medoid_dist</span><span class="p">[</span><span class="n">medoid_dist</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="p">])</span>
        <span class="n">divergent_seqs_medoids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">num_over_25</span><span class="p">))</span>
    <span class="k">except</span> <span class="nb">ValueError</span><span class="p">:</span>
        <span class="n">divergent_seqs_medoids</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))</span>
        <span class="n">num_over_25</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">runs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">medoids</span><span class="p">,</span><span class="n">membership</span><span class="p">,</span><span class="n">medoid_dist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_over_25</span> <span class="o">&lt;</span> <span class="n">best_run</span><span class="p">:</span>
        <span class="n">best_run</span> <span class="o">=</span> <span class="n">num_over_25</span>
        <span class="n">best_run_idx</span> <span class="o">=</span> <span class="n">i</span>
        
<span class="n">medoids</span><span class="p">,</span><span class="n">membership</span><span class="p">,</span><span class="n">medoid_dist</span> <span class="o">=</span> <span class="n">runs</span><span class="p">[</span><span class="n">best_run_idx</span><span class="p">]</span>         
<span class="k">print</span><span class="p">(</span><span class="s">"Medoids: "</span><span class="p">,</span> <span class="n">p_dm_df</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="n">medoids</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Number of Distances &gt; 30</span><span class="si">%</span><span class="s">: {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">medoid_dist</span><span class="p">[</span><span class="n">medoid_dist</span> <span class="o">&gt;</span> <span class="mf">0.30</span><span class="p">])))</span>
<span class="n">medoid_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
        
        

</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>Medoids:  Index(['WZFE', 'XHHU', 'XVRU', 'GNPX', 'BERS', 'DDRL', 'BYQM', 'CKDK', 'CWZU',
       'EDIT', 'IHPC', 'Eucgr_v1.1', 'HQRJ', 'FFFY', 'GDKK', 'EYRD', 'DUQG',
       'PEZP', 'HUSX', 'PPPZ', 'JNKW', 'EJBY', 'LAPO', 'CPKP', 'HOKG', 'NMGG',
       'WOHL', 'FZQN', 'OSMU', 'MFIN', 'AXNH', 'BVOF', 'KEGA', 'VXKB', 'QOXT',
       'TEZA', 'Ambtr_v1.0.27', 'UZXL', 'VGHH', 'HAEU', 'LELS', 'WBOD', 'NBMW',
       'ZENX', 'XZME', 'MRKX', 'TIUZ', 'TJQY', 'ZCUA', 'DZLN'],
      dtype='object')

Number of Distances &gt; 30%: 57


/usr/local/lib/python3.5/site-packages/numpy/core/_methods.py:59: RuntimeWarning: Mean of empty slice.
  warnings.warn("Mean of empty slice.", RuntimeWarning)





&lt;matplotlib.axes._subplots.AxesSubplot at 0x10fba0048&gt;
</code></pre>
</div>

<p><img src="SequenceClusters_files/SequenceClusters_34_3.png" alt="png" /></p>

<p>The next step will be to write a dedicated script to systematically check K clusters until a minimum number of sequences is found to represent a maximum number of species.</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code>
</code></pre>
</div>

			</div>
		</div>			
		<div class="col-md-1"></div>
	</div>		



	

	<div class="bigspacer"></div>
	<div class="row">
		<div class="col-md-3">
			<div class="head">
				<a href="/blog/Introducing-HybPiper" class="off">Introducing HybPiper</a>
			</div>
			<div class="smallnote">
				18 Jul 2016
				
				by <a class="off" href="/team/matt-johnson">mossmatters</a>
								
			</div>	
		</div>
		<div class="col-md-8">		
			<div style="height:5px;"></div>			
			
			<div class="post">
				
<p><img src="HybPiper_images/hybpiper_logo_vector.jpg" alt="HybPiper Logo" style="width: 400px;" /></p>

<p>This week marks the “official” release of <a href="github.com/mossmatters/HybPiper">HybPiper</a>, the bioinformatics pipeline I’ve been working on for most of my post-doc. We published a paper on the method, and demonstrated how it can be used for phylogenetics, in this month’s Applications in Plant Sciences (open access).</p>

<p>This work was a collaboration between the Pleurocarpous Moss Tree of Life team and the Zerega lab at the Chicago Botanic Garden. We used draft genomic data generated from Artocarpus camansi, the wild progenitor of breadfruit, to design a set of genetic markers to be used for phylogenetics and gene family evolution analysis (for more details, see the companion paper in APPS). Using a technique known as HybSeq, high-throughput sequencing libraries are enriched for genes of interest via hybridization with short RNA probe sequences. Although a few other methods exist to tackle target enrichment data, our method is more streamlined for HybSeq data: extracting coding sequences and the flanking intron sequences for phylogenetics. In the paper we describe HybPiper and demonstrate its use on 458 genes enriched for 28 species of Artocarpus and its relatives.</p>

<h2 id="main-features">Main Features</h2>

<p>To conduct phylogenetic analysis, high-throughput DNA sequencing reads need to be re-assembled into continuous sequences. HybPiper uses several pre-existing bioinformatics tools to automate the process while maintaining an organized set of intermediate files that can aid in more detailed analysis. The main script of HybPiper has three phases:HybPiper_Infographic</p>

<p>Sorts reads by mapping them to target sequences, using BLASTx (protein targets) or BWA (nucleotide targets).
Assembles contigs for each gene separately.
Aligns contigs to target sequences and extracts exon (coding) sequence.
HybPiper also includes a number of scripts that can be used to extract more information from the sequencing data, including:</p>

<p>Coverage depth and target enrichment efficiency data, including a script for plotting a heat map of gene recovery.
Retrieval of non-coding flanking sequences (i.e. introns) either separately or together with the coding sequences (supercontigs).
Identification of putative paralogous sequences, and methods to help distinguish ancient from recent paralogs.
Process HybPiper results from many samples; for example, generation of separate FASTA files for each gene, ready for phylogenetics pipelines
For more information about HybPiper, including complete tutorials on installation, usage, and an example toy dataset, check out the GitHub page and the HybPiper wiki.</p>

<h2 id="developing-hybpiper">Developing HybPiper</h2>

<p>Coming up with a consistent pipeline for processing target enrichment data was one of the primary tasks for my post-doc as part of the NSF Tree of Life grant that our team received in 2013. As part of that grant, we’ve developed over 800 markers to reconstruct the phylogeny of nearly 400 pleurocarpous mosses, so I new that the pipeline would have to be very efficient.  Along the way I discovered tools such as GNU Parallel, which greatly improved the speed of mapping, sequence assembly and exon extraction. Early in the process we made the decision to develop a pipeline that could itself be a product of the grant, a tool with broad applications to address the growing use of high-throughput sequencing and target enrichment in  phylogenetic systematics of non-model organisms.</p>

<p>Many of the features in HybPiper were suggested by several of the co-authors on the APPS paper, particularly Yang Liu, Rafael Medina, and Elliot Gardner. Twitter also played an important role: when I discovered that the assembler I was using (Velvet) was generating quite questionable assemblies, a couple people suggested SPAdes as a replacement, which has worked out great!</p>

<h2 id="naming-hybpiper">Naming HybPiper</h2>

<p>Just before submitting the manuscript, my advisor called me into his office and with a very serious tone said “You need a new name for the pipeline.” One week later, we had one of the most entertaining lab meetings ever– here’s a brief look into the creative process. HybPiper brainstorm</p>

<p><img src="HybPiper_images/hybpiper_whiteboard.jpg" alt="HybPiper Whiteboard" style="width: 400px;" /></p>

<p>After 46 minutes and nearly calling the pipeline Skunk Trapper, we had an epiphany with HybPiper. Elliot, who was not at the meeting, provided the logo the very next day.</p>

<p>Development of HybPiper is ongoing, and I hope to maintain and extend the code to other applications in the future. For example, I’ve already received a few requests from users who would like to see an expansion of the handling of HybPiper for non-coding regions, such as plastid intergenic markers.</p>

			</div>
		</div>			
		<div class="col-md-1"></div>
	</div>		



	

	<div class="bigspacer"></div>
	<div class="row">
		<div class="col-md-3">
			<div class="head">
				<a href="/blog/Touring-Peatland-Restoration" class="off">Touring a Peatland Restoration Site</a>
			</div>
			<div class="smallnote">
				03 Aug 2015
				
				by <a class="off" href="/team/matt-johnson">mossmatters</a>
								
			</div>	
		</div>
		<div class="col-md-8">		
			<div style="height:5px;"></div>			
			
			<div class="post">
				<p>For someone passionate about <em>Sphagnum</em>, the thought of visiting a place where peat moss is harvested for commercial use might seem a little like an ornithologist visiting a sport-hunting facility, or a mollusk researcher watching a big diesel spewing ship dredge a river channel. But when I saw that a tour of SunGrow’s peat harvesting and restoration facility in Seba Beach was on the menu at the 2015 Botany conference, I signed up instantly.</p>

<p>I must admit that I was initially skeptical; although it is sometimes classified as a renewable resource, peat forms very slowly. Bog growth rate <a href="http://biogeosciences.net/9/2737/2012/bg-9-2737-2012.pdf">has been measured at about 1 cm per year</a>, and the typical <a href="http://www.gret-perg.ulaval.ca/fileadmin/fichiers/fichiersGRET/pdf/Doc_generale/Wetlands.pdf">depth of usable peat in Canada is 3-5 meters</a>. So even if conditions instantly returned to peat accumulation, it would take hundreds of years to regenerate. This makes it more comparable not to other renewables like switchgrass or even loblolly pine, but rather closer on the renewable scale to coal.</p>

<p>I was put at ease by <a href="http://www2.ulaval.ca/fileadmin/ulaval_ca/Images/recherche/bd/chercheur/fiche/12039.html">Dr. Line Rochefort, of Laval University in Quebec</a>, who conducted the tour. She has been working with peat harvesting companies for 25 years, advising them on best practices. She helped organize the <a href="http://peatmoss.com/">Canadian Sphagnum Peat Moss Association</a>, a collection of researchers and companies around Canada with a stated interest in responsibly restoring peatland habitat after harvesting. This is not mandated by the Canadian government, which only requires that the site be returned to a wetland. But something as simple as filling in the ditches would never return the peatland to its original state.</p>

<p><img src="PeatRestore_images/speech.jpg" alt="Peatland Restoration Tour" style="width: 300px;" /><br />
<em>Line Rochefort speaks to the group about peatland restoration</em></p>

<p>Essentially, the restoration of peatlands comes down to one argument: peatlands are going to get harvested, as long as there is demand for peat in the horticultural industry (the association estimates peat harvesting is worth $337 million annually). It would be much better if we (as humans) did this as responsibly as possible, rather than by taking all we could and running away. Peat harvesting has the potential to impact the environment in the short term, through wetland destruction; and long term– removing a peatland causes a net increase of carbon emissions beyond just the removal of living plant material.</p>

<p><img src="PeatRestore_images/peat-harvesters.jpg" alt="Peat Harvesters" style="width: 300px;" /><br />
<em>Peat harvesters are essentially giant vacuums</em></p>

<p>After harvesting, even if the drainage ditches are plugged, the peatland cannot recover. Dr. Rochefort mentioned visiting peatlands in Colorado that had been harvested with no attempt to restore them; after 140 years, they still look like barren wastelands. This is because Sphagnum peat moss, the most important plant for northern boreal bog peatlands, cannot recolonize the peatland without some help. Dr. Rochefort told us that when she searches for a “donor site”– a peatland that can have its top layer removed and distributed atop harvested peat for reclamation– the most important plant is not Sphagnum, but another moss, <em>Polytrichum</em>.</p>

<p><img src="PeatRestore_images/Sphagnum-polytrichum.jpg" alt="Sphagnum and Polytrichum" style="width: 300px;" /><br /><em>Polytrichum (left) and Sphagnum (right). Stubby bryologist fingers for scale.</em></p>

<p><em>Polytrichum</em> is an upright moss with hardy “stems” that form a matrix onto which Sphagnum can grab hold and begin to build hummocks and accumulate peat. In the first phase of peatland restoration, material from the donor site is spread onto a harvested peatland in a 1:10 ratio (one hectare of donor site can be spread across 10 hectares of harvested peatland). Sphagnum will regenerate from broken fragments, but have a very hard time establishing on its own. <em>Polytrichum</em>, meanwhile, will easily germinate from its very abundant spore bank in the newly spread donor site material. Dr. Rochefort said that <em>Polytrichum</em> is so important that they make sure to add rock phosphate to the site to help <em>Polytrichum</em> spores germinate.</p>

<p>During the tour, we visited three sites: one that had been reclaimed using their procedure in 2009, another that had been reclaimed in a less “rigorous” way in 1994, and a donor site. The more recent reclamation site had an abundance of all the types of mosses you would see in a mature bog: <em>Sphagnum magellanicum</em>, <em>Sphagnum fuscum</em>, <em>Sphagnum angustifolium</em>, <em>Aulacomnium</em> palustre, and a few “brown mosses” such as <em>Tomenthypnum</em> and <em>Drepanocladus</em>. The vegetation had recovered nicely, but did have some species that did not belong in a bog: cotton grass and small birch trees were the most obvious. Dr. Rochefort said that based on earlier restorations, these plants were likely to die out as the Sphagnum took ahold of the habitat.</p>

<p>The elder reclamation site was more interesting from a botanizing perspective. Near the road there was a part where no moss mixture had been spread, and it looked like the wasteland Dr. Rochefort described from Colorado. Just a few feet away, there was a lush and healthy lawn of Sphagnum, perhaps ten species living happily. Although it wasn’t a true raised bog– that might take hundreds of years for the peat to regrow– I would not have been able to tell it was bare peat just 20 years earlier.</p>

<p>The peat extraction process is pretty interesting itself. They actually harvest in the dead of winter, once everything is frozen and covered with snow. Then they use a harrowing device to remove the top 20 cm of plant material– everything including mosses, grasses, and even black spruce trees! This material is kept in a pile for the winter and spring; the water from the snow and the mulch from the woodchips helps maintain the plants while they await spreading on a new peatland. At this point someone asked about the impact of cutting down all the spruce trees. “Compared to the peat moss,” Dr. Rochefort said, “the carbon produced by the spruce is negligible.” Such a difference compared to other restoration efforts, where mosses are barely considered, here is perhaps the ultimate situation in which moss matters.</p>

<p>In the spring, the peat is turned and dried until late summer. Then, extremely large driving vacuums come along and suck up the peat. They turn over the peat behind themselves, and once this layer dries, the process can be repeated. They may get 20-30 years of peat harvest from a single plot, and after this is done, plant material from a donor site will be spread to encourage restoration.</p>

<p>Overall, I left with a positive opinion of the efforts being done at SunGro. I won’t say too much about the political and business implications of peat harvesting, as I will leave that to those who are more informed on those issues. From a botanist’s perspective, and one who has some experience with natural peatlands, their efforts are commendable. I thoroughly enjoyed the tour, not least because I finally got the opportunity to get away from the computer and look at some plants!</p>

			</div>
		</div>			
		<div class="col-md-1"></div>
	</div>		



<div class="bigspacer"></div>	
<div class="row">
	<div class="col-md-12 text-center">
		<a class="off" href="//archive/">
			<div class="smallhead">Archive</div>
			<i class="text-gray fa fa-chevron-circle-down fa-2x"></i>
		</a>
	</div>
</div>
   </div>


  <!-- Static bottom navbar -->
  <nav class="navbar navbar-default navbar-fixed-bottom">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-bottom-collapse"> <!-- NOTE! data-target was changed to jb-bottom-collapse -->
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <!-- Collect the nav links, forms, and other content for toggling -->
      <div class="collapse navbar-collapse" id="jb-bottom-collapse">
        <ul class="nav navbar-nav navbar-left navbar-small">
          <li><a href=http://depts.ttu.edu/biology>Biological Sciences</a></li>
          <li><a href=http://www.ttu.edu>Texas Tech University</a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right navbar-small">
          <li><a href='/about.html'>About</a></li>
          
          <li><a href='/join.html'>Join us</a></li>
        </ul>
      </div><!-- /.navbar-collapse -->
    </div>
  </nav>
 


    




  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-86098012-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86098012-1', 'auto');
  ga('send', 'pageview');

</script>





    <!-- Latest compiled and minified JavaScript, requires jQuery 1.x (2.x not supported in IE8) -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="/assets/themes/lab/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>

